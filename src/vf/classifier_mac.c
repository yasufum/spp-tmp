/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright(c) 2017-2019 Nippon Telegraph and Telephone Corporation
 */

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <math.h>

#include <rte_common.h>
#include <rte_mbuf.h>
#include <rte_log.h>
#include <rte_cycles.h>
#include <rte_malloc.h>
#include <rte_memcpy.h>
#include <rte_random.h>
#include <rte_byteorder.h>
#include <rte_per_lcore.h>
#include <rte_eal.h>
#include <rte_launch.h>
#include <rte_hash.h>

#include "spp_vf.h"
#include "spp_port.h"
#include "classifier_mac.h"

#define RTE_LOGTYPE_SPP_CLASSIFIER_MAC RTE_LOGTYPE_USER1

#ifdef RTE_MACHINE_CPUFLAG_SSE4_2
#include <rte_hash_crc.h>
#define DEFAULT_HASH_FUNC rte_hash_crc
#else
#include <rte_jhash.h>
#define DEFAULT_HASH_FUNC rte_jhash
#endif

/* number of classifier mac table entry */
#define NUM_CLASSIFIER_MAC_TABLE_ENTRY 128

/* number of classifier information (reference/update) */
#define NUM_CLASSIFIER_MAC_INFO 2

/* interval that wait until change update index (micro second) */
#define CHANGE_UPDATE_INDEX_WAIT_INTERVAL SPP_CHANGE_UPDATE_INTERVAL

/*
 *  interval that transmit burst packet,
 *  if buffer is not filled (nano second)
 */
#define DRAIN_TX_PACKET_INTERVAL 100

/* VID of VLAN untagged */
#define VLAN_UNTAGGED_VID 0x0fff

/*
 * hash table name buffer size
 *[reson for value]
 *	in dpdk's lib/librte_hash/rte_cuckoo_hash.c
 *		snprintf(ring_name, sizeof(ring_name), "HT_%s", params->name);
 *		snprintf(hash_name, sizeof(hash_name), "HT_%s", params->name);
 *	ring_name buffer size is RTE_RING_NAMESIZE
 *	hash_name buffer size is RTE_HASH_NAMESIZE
 */
static const size_t HASH_TABLE_NAME_BUF_SZ =
		((RTE_HASH_NAMESIZE < RTE_RING_NAMESIZE) ?  RTE_HASH_NAMESIZE :
		RTE_RING_NAMESIZE) - 3;

/* mac address string(xx:xx:xx:xx:xx:xx) buffer size */
static const size_t ETHER_ADDR_STR_BUF_SZ =
		ETHER_ADDR_LEN * 2 + (ETHER_ADDR_LEN - 1) + 1;

/* classified data (destination port, target packets, etc) */
struct classified_data {
	/* interface type (see "enum port_type") */
	enum port_type  iface_type;

	/* index of ports handled by classifier */
	int             iface_no;

	/* id for interface generated by spp_vf */
	int             iface_no_global;

	/* port id generated by DPDK */
	uint16_t        port;

	/* the number of packets in pkts[] */
	uint16_t        num_pkt;

	/* packet array to be classified */
	struct rte_mbuf *pkts[MAX_PKT_BURST];
};

/* mac address classification */
struct mac_classification {
	/* hash table keeps classification */
	struct rte_hash *classification_tab;

	/* number of valid classification */
	int num_active_classified;

	/* index of valid classification */
	int active_classifieds[RTE_MAX_ETHPORTS];

	/* index of default classification */
	int default_classified;
};

/* classifier component information */
struct component_info {
	/* component name */
	char name[SPP_NAME_STR_LEN];

	/* mac address entry flag */
	int mac_addr_entry;

	/* mac address classification per vlan-id */
	struct mac_classification *mac_classifications[SPP_NUM_VLAN_VID];

	/* number of transmission ports */
	int n_classified_data_tx;

	/* receive port handled by classifier */
	struct classified_data classified_data_rx;

	/* transmission ports handled by classifier */
	struct classified_data classified_data_tx[RTE_MAX_ETHPORTS];
};

/* classifier management information */
struct management_info {
	/* classifier information */
	struct component_info cmp_infos[NUM_CLASSIFIER_MAC_INFO];

	/* Reference index number for classifier information */
	volatile int ref_index;

	/* Update index number for classifier information */
	volatile int upd_index;

	/* used flag */
	volatile int is_used;
};

/* classifier information per lcore */
static struct management_info g_mng_infos[RTE_MAX_LCORE];

/**
 * Hash table count used for making a name of hash table
 *
 * This function is required because it is incremented at the time of use,
 * but since we want to start at 0.
 */
static rte_atomic16_t g_hash_table_count = RTE_ATOMIC16_INIT(0xff);

/* get vid from packet */
static inline uint16_t
get_vid(const struct rte_mbuf *pkt)
{
	struct ether_hdr *eth;
	struct vlan_hdr *vh;

	eth = rte_pktmbuf_mtod(pkt, struct ether_hdr *);
	if (eth->ether_type == rte_cpu_to_be_16(ETHER_TYPE_VLAN)) {
		/* vlan tagged */
		vh = (struct vlan_hdr *)(eth + 1);
		return rte_be_to_cpu_16(vh->vlan_tci) & 0x0fff;
	}

	/* vlan untagged */
	return VLAN_UNTAGGED_VID;
}

#if RTE_LOG_DP_LEVEL >= RTE_LOG_DEBUG

#define LOG_DBG(name, fmt, ...)                                        \
		RTE_LOG_DP(DEBUG, SPP_CLASSIFIER_MAC,                  \
				"[%s]Log(%s:%d):"fmt,                  \
				name, __func__, __LINE__, __VA_ARGS__)

static void
log_packet(const char *name, struct rte_mbuf *pkt,
		const char *func_name, int line_num)
{
	struct ether_hdr *eth;
	uint16_t vid;
	char mac_addr_str[2][ETHER_ADDR_STR_BUF_SZ];

	eth = rte_pktmbuf_mtod(pkt, struct ether_hdr *);
	vid = get_vid(pkt);

	ether_format_addr(mac_addr_str[0], sizeof(mac_addr_str),
			&eth->d_addr);
	ether_format_addr(mac_addr_str[1], sizeof(mac_addr_str),
			&eth->s_addr);

	RTE_LOG_DP(DEBUG, SPP_CLASSIFIER_MAC,
			"[%s]Packet(%s:%d). d_addr=%s, s_addr=%s, "
			"vid=%hu, pktlen=%u\n",
			name,
			func_name,
			line_num,
			mac_addr_str[0],
			mac_addr_str[1],
			vid,
			rte_pktmbuf_pkt_len(pkt));
}

#define LOG_PKT(name, pkt) \
		log_packet(name, pkt, __func__, __LINE__)

static void
log_classification(
		long clsd_idx,
		struct rte_mbuf *pkt,
		struct component_info *cmp_info,
		struct classified_data *clsd_data,
		const char *func_name,
		int line_num)
{
	struct ether_hdr *eth;
	uint16_t vid;
	char mac_addr_str[2][ETHER_ADDR_STR_BUF_SZ];
	char iface_str[SPP_NAME_STR_LEN];

	eth = rte_pktmbuf_mtod(pkt, struct ether_hdr *);
	vid = get_vid(pkt);

	ether_format_addr(mac_addr_str[0], sizeof(mac_addr_str),
			&eth->d_addr);
	ether_format_addr(mac_addr_str[1], sizeof(mac_addr_str),
			&eth->s_addr);

	if (clsd_idx < 0)
		snprintf(iface_str, sizeof(iface_str), "%ld", clsd_idx);
	else
		spp_format_port_string(
				iface_str,
				clsd_data[clsd_idx].iface_type,
				clsd_data[clsd_idx].iface_no_global);

	RTE_LOG_DP(DEBUG, SPP_CLASSIFIER_MAC,
			"[%s]Classification(%s:%d). d_addr=%s, "
			"s_addr=%s, vid=%hu, pktlen=%u, tx_iface=%s\n",
			cmp_info->name,
			func_name,
			line_num,
			mac_addr_str[0],
			mac_addr_str[1],
			vid,
			rte_pktmbuf_pkt_len(pkt),
			iface_str);
}

#define LOG_CLS(clsd_idx, pkt, cmp_info, clsd_data)                    \
		log_classification(clsd_idx, pkt, cmp_info, clsd_data, \
				__func__, __LINE__)

static void
log_entry(
		long clsd_idx,
		uint16_t vid,
		const char *mac_addr_str,
		struct component_info *cmp_info,
		struct classified_data *clsd_data,
		const char *func_name,
		int line_num)
{
	char iface_str[SPP_NAME_STR_LEN];

	if (clsd_idx < 0)
		snprintf(iface_str, sizeof(iface_str), "%ld", clsd_idx);
	else
		spp_format_port_string(
				iface_str,
				clsd_data[clsd_idx].iface_type,
				clsd_data[clsd_idx].iface_no_global);

	RTE_LOG_DP(DEBUG, SPP_CLASSIFIER_MAC,
			"[%s]Entry(%s:%d). vid=%hu, mac_addr=%s, iface=%s\n",
			cmp_info->name,
			func_name,
			line_num,
			vid,
			mac_addr_str,
			iface_str);
}
#define LOG_ENT(clsd_idx, vid, mac_addr_str, cmp_info, clsd_data)           \
		log_entry(clsd_idx, vid, mac_addr_str, cmp_info, clsd_data, \
				__func__, __LINE__)
#else
#define LOG_DBG(name, fmt, ...)
#define LOG_PKT(name, pkt)
#define LOG_CLS(pkt, clsd_idx, cmp_info, clsd_data)
#define LOG_ENT(clsd_idx, vid, mac_addr_str, cmp_info, clsd_data)
#endif

/* check if management information is used. */
static inline int
is_used_mng_info(const struct management_info *mng_info)
{
	return (mng_info != NULL && mng_info->is_used);
}

/* create mac classification instance. */
static struct mac_classification *
create_mac_classification(void)
{
	struct mac_classification *mac_cls;
	char hash_tab_name[HASH_TABLE_NAME_BUF_SZ];
	struct rte_hash **mac_cls_tab;

	mac_cls = (struct mac_classification *)rte_zmalloc(
			NULL, sizeof(struct mac_classification), 0);

	if (unlikely(mac_cls == NULL))
		return NULL;

	mac_cls->num_active_classified = 0;
	mac_cls->default_classified = -1;

	mac_cls_tab = &mac_cls->classification_tab;

	/* make hash table name(require uniqueness between processes) */
	sprintf(hash_tab_name, "cmtab_%07x%02hx",
			getpid(),
			rte_atomic16_add_return(&g_hash_table_count, 1));

	RTE_LOG(INFO, SPP_CLASSIFIER_MAC, "Create table. name=%s, bufsz=%lu\n",
			hash_tab_name, HASH_TABLE_NAME_BUF_SZ);

	/* set hash creating parameters */
	struct rte_hash_parameters hash_params = {
			.name      = hash_tab_name,
			.entries   = NUM_CLASSIFIER_MAC_TABLE_ENTRY,
			.key_len   = sizeof(struct ether_addr),
			.hash_func = DEFAULT_HASH_FUNC,
			.hash_func_init_val = 0,
			.socket_id = rte_socket_id(),
	};

	/* create classifier mac table (hash table) */
	*mac_cls_tab = rte_hash_create(&hash_params);
	if (unlikely(*mac_cls_tab == NULL)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
				"Cannot create mac classification table. "
				"name=%s\n", hash_tab_name);
		rte_free(mac_cls);
		return NULL;
	}

	return mac_cls;
}

/* initialize classifier information. */
static int
init_component_info(struct component_info *cmp_info,
		const struct spp_component_info *component_info)
{
	int ret = SPP_RET_NG;
	int i;
	struct mac_classification *mac_cls;
	struct ether_addr eth_addr;
	char mac_addr_str[ETHER_ADDR_STR_BUF_SZ];
	struct classified_data *clsd_data_rx = &cmp_info->classified_data_rx;
	struct classified_data *clsd_data_tx = cmp_info->classified_data_tx;
	struct spp_port_info *tx_port = NULL;
	uint16_t vid;

	/* set rx */
	if (component_info->num_rx_port == 0) {
		clsd_data_rx->iface_type      = UNDEF;
		clsd_data_rx->iface_no        = 0;
		clsd_data_rx->iface_no_global = 0;
		clsd_data_rx->port            = 0;
		clsd_data_rx->num_pkt         = 0;
	} else {
		clsd_data_rx->iface_type      =
				component_info->rx_ports[0]->iface_type;
		clsd_data_rx->iface_no        = 0;
		clsd_data_rx->iface_no_global =
				component_info->rx_ports[0]->iface_no;
		clsd_data_rx->port            =
				component_info->rx_ports[0]->dpdk_port;
		clsd_data_rx->num_pkt         = 0;
	}

	/* set tx */
	cmp_info->n_classified_data_tx = component_info->num_tx_port;
	cmp_info->mac_addr_entry = 0;
	for (i = 0; i < component_info->num_tx_port; i++) {
		tx_port = component_info->tx_ports[i];
		vid = tx_port->class_id.vlantag.vid;

		/* store ports information */
		clsd_data_tx[i].iface_type      = tx_port->iface_type;
		clsd_data_tx[i].iface_no        = i;
		clsd_data_tx[i].iface_no_global = tx_port->iface_no;
		clsd_data_tx[i].port            = tx_port->dpdk_port;
		clsd_data_tx[i].num_pkt         = 0;

		if (tx_port->class_id.mac_addr == 0)
			continue;

		/* if mac classification is NULL, make instance */
		if (unlikely(cmp_info->mac_classifications[vid] == NULL)) {
			RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
					"Mac classification is not registered."
					" create. vid=%hu\n", vid);
			cmp_info->mac_classifications[vid] =
					create_mac_classification();
			if (unlikely(cmp_info->mac_classifications[vid] ==
					NULL))
				return SPP_RET_NG;
		}
		mac_cls = cmp_info->mac_classifications[vid];

		/* store active tx_port that associate with mac address */
		mac_cls->active_classifieds[
				mac_cls->num_active_classified++] = i;

		/* mac address entry flag set */
		cmp_info->mac_addr_entry = 1;

		/* store default classified */
		if (unlikely(tx_port->class_id.mac_addr ==
				SPP_DEFAULT_CLASSIFIED_DMY_ADDR)) {
			mac_cls->default_classified = i;
			RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
					"default classified. vid=%hu, "
					"iface_type=%d, iface_no=%d, "
					"dpdk_port=%d\n",
					vid,
					tx_port->iface_type,
					tx_port->iface_no,
					tx_port->dpdk_port);
			continue;
		}

		/* add entry to classifier mac table */
		rte_memcpy(&eth_addr, &tx_port->class_id.mac_addr,
				ETHER_ADDR_LEN);
		ether_format_addr(mac_addr_str, sizeof(mac_addr_str),
				&eth_addr);

		ret = rte_hash_add_key_data(mac_cls->classification_tab,
				(void *)&eth_addr, (void *)(long)i);
		if (unlikely(ret < 0)) {
			RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
					"Cannot add entry to classifier mac "
					"table. ret=%d, vid=%hu, "
					"mac_addr=%s\n",
					ret, vid, mac_addr_str);
			return SPP_RET_NG;
		}

		RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
				"Add entry to classifier mac table. "
				"vid=%hu, mac_addr=%s, iface_type=%d, "
				"iface_no=%d, dpdk_port=%d\n",
				vid,
				mac_addr_str,
				tx_port->iface_type,
				tx_port->iface_no,
				tx_port->dpdk_port);
	}

	return SPP_RET_OK;
}

/* free mac classification instance. */
static inline void
free_mac_classification(struct mac_classification *mac_cls)
{
	if (mac_cls == NULL)
		return;

	if (mac_cls->classification_tab != NULL)
		rte_hash_free(mac_cls->classification_tab);

	rte_free(mac_cls);
}

/* uninitialize classifier information. */
static void
uninit_component_info(struct component_info *cmp_info)
{
	int i;

	for (i = 0; i < SPP_NUM_VLAN_VID; ++i)
		free_mac_classification(cmp_info->mac_classifications[i]);

	memset(cmp_info, 0, sizeof(struct component_info));
}

/* uninitialize classifier. */
static void
uninit_classifier(struct management_info *mng_info)
{
	int i;

	mng_info->is_used = 0;

	for (i = 0; i < NUM_CLASSIFIER_MAC_INFO; ++i)
		uninit_component_info(mng_info->cmp_infos + (long)i);

	memset(mng_info, 0, sizeof(struct management_info));
}

/* transmit packet to one destination. */
static inline void
transmit_packet(struct classified_data *clsd_data)
{
	int i;
	uint16_t n_tx;

	/* transmit packets */
	n_tx = spp_eth_tx_burst(clsd_data->port, 0,
			clsd_data->pkts, clsd_data->num_pkt);

	/* free cannot transmit packets */
	if (unlikely(n_tx != clsd_data->num_pkt)) {
		for (i = n_tx; i < clsd_data->num_pkt; i++)
			rte_pktmbuf_free(clsd_data->pkts[i]);
		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
				"drop packets(tx). num=%hu, dpdk_port=%hu\n",
				(uint16_t)(clsd_data->num_pkt - n_tx),
				clsd_data->port);
	}

	clsd_data->num_pkt = 0;
}

/* transmit packet to one destination. */
static inline void
transmit_all_packet(struct component_info *cmp_info)
{
	int i;
	struct classified_data *clsd_data_tx = cmp_info->classified_data_tx;

	for (i = 0; i < cmp_info->n_classified_data_tx; i++) {
		if (unlikely(clsd_data_tx[i].num_pkt != 0)) {
			RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
					"transmit all packets (drain). "
					"index=%d, "
					"num_pkt=%hu\n",
					i,
					clsd_data_tx[i].num_pkt);
			transmit_packet(&clsd_data_tx[i]);
		}
	}
}

/* set mbuf pointer to tx buffer and transmit packet, if buffer is filled */
static inline void
push_packet(struct rte_mbuf *pkt, struct classified_data *clsd_data)
{
	clsd_data->pkts[clsd_data->num_pkt++] = pkt;

	/* transmit packet, if buffer is filled */
	if (unlikely(clsd_data->num_pkt == MAX_PKT_BURST)) {
		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
				"transmit packets (buffer is filled). "
				"iface_type=%d, iface_no={%d,%d}, "
				"tx_port=%hu, num_pkt=%hu\n",
				clsd_data->iface_type,
				clsd_data->iface_no_global,
				clsd_data->iface_no,
				clsd_data->port,
				clsd_data->num_pkt);
		transmit_packet(clsd_data);
	}
}

/* get index of general default classified */
static inline int
get_general_default_classified_index(struct component_info *cmp_info)
{
	struct mac_classification *mac_cls;

	mac_cls = cmp_info->mac_classifications[VLAN_UNTAGGED_VID];
	if (unlikely(mac_cls == NULL)) {
		LOG_DBG(cmp_info->name, "Untagged's default is not set. "
				"vid=%d\n", (int)VLAN_UNTAGGED_VID);
		return SPP_RET_NG;
	}

	return mac_cls->default_classified;
}

/* handle L2 multicast(include broadcast) packet */
static inline void
handle_l2multicast_packet(struct rte_mbuf *pkt,
		struct component_info *cmp_info,
		struct classified_data *clsd_data)
{
	int i;
	struct mac_classification *mac_cls;
	uint16_t vid = get_vid(pkt);
	int gen_def_clsd_idx = get_general_default_classified_index(cmp_info);
	int n_act_clsd;

	/* select mac address classification by vid */
	mac_cls = cmp_info->mac_classifications[vid];
	if (unlikely(mac_cls == NULL ||
			mac_cls->num_active_classified == 0)) {
		/* specific vlan is not registered
		 * use untagged's default(as general default)
		 */
		if (unlikely(gen_def_clsd_idx < 0)) {
			/* untagged's default is not registered too */
			RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
					"No entry.(l2 multicast packet)\n");
			rte_pktmbuf_free(pkt);
			return;
		}

		/* transmit to untagged's default(as general default) */
		LOG_CLS((long)gen_def_clsd_idx, pkt, cmp_info, clsd_data);
		push_packet(pkt, clsd_data + (long)gen_def_clsd_idx);
		return;
	}

	/* add to mbuf's refcnt */
	n_act_clsd = mac_cls->num_active_classified;
	if (gen_def_clsd_idx >= 0 && vid != VLAN_UNTAGGED_VID)
		++n_act_clsd;

	rte_mbuf_refcnt_update(pkt, (int16_t)(n_act_clsd - 1));

	/* transmit to specific segment & general default */
	for (i = 0; i < mac_cls->num_active_classified; i++) {
		LOG_CLS((long)mac_cls->active_classifieds[i],
				pkt, cmp_info, clsd_data);
		push_packet(pkt, clsd_data +
				(long)mac_cls->active_classifieds[i]);
	}

	if (gen_def_clsd_idx >= 0 && vid != VLAN_UNTAGGED_VID) {
		LOG_CLS((long)gen_def_clsd_idx, pkt, cmp_info, clsd_data);
		push_packet(pkt, clsd_data + (long)gen_def_clsd_idx);
	}
}

/* select index of classified */
static inline int
select_classified_index(const struct rte_mbuf *pkt,
		struct component_info *cmp_info)
{
	int ret;
	struct ether_hdr *eth;
	void *lookup_data;
	struct mac_classification *mac_cls;
	uint16_t vid;

	eth = rte_pktmbuf_mtod(pkt, struct ether_hdr *);
	vid = get_vid(pkt);

	/* select mac address classification by vid */
	mac_cls = cmp_info->mac_classifications[vid];
	if (unlikely(mac_cls == NULL)) {
		LOG_DBG(cmp_info->name, "Mac classification is not "
				"registered. vid=%hu\n", vid);
		return get_general_default_classified_index(cmp_info);
	}

	/* find in table (by destination mac address) */
	ret = rte_hash_lookup_data(mac_cls->classification_tab,
			(const void *)&eth->d_addr, &lookup_data);
	if (ret >= 0) {
		LOG_DBG(cmp_info->name, "Mac address is registered. "
				"ret=%d, vid=%hu\n", ret, vid);
		return (int)(long)lookup_data;
	}

	LOG_DBG(cmp_info->name,
			"Mac address is not registered. ret=%d, "
			"(EINVAL=%d, ENOENT=%d)\n", ret, EINVAL, ENOENT);

	/* check if packet is l2 multicast */
	if (unlikely(is_multicast_ether_addr(&eth->d_addr)))
		return -2;

	/* if default is not set, use untagged's default */
	if (unlikely(mac_cls->default_classified < 0 &&
			vid != VLAN_UNTAGGED_VID)) {
		LOG_DBG(cmp_info->name, "Vid's default is not set. "
				"use general default. vid=%hu\n", vid);
		return get_general_default_classified_index(cmp_info);
	}

	/* use default */
	LOG_DBG(cmp_info->name, "Use vid's default. vid=%hu\n", vid);
	return mac_cls->default_classified;
}

/*
 * classify packet by destination mac address,
 * and transmit packet (conditional).
 */
static inline void
classify_packet(struct rte_mbuf **rx_pkts, uint16_t n_rx,
		struct component_info *cmp_info,
		struct classified_data *clsd_data)
{
	int i;
	long clsd_idx;

	for (i = 0; i < n_rx; i++) {
		LOG_PKT(cmp_info->name, rx_pkts[i]);

		clsd_idx = select_classified_index(rx_pkts[i], cmp_info);
		LOG_CLS(clsd_idx, rx_pkts[i], cmp_info, clsd_data);

		if (likely(clsd_idx >= 0)) {
			LOG_DBG(cmp_info->name, "as unicast packet. i=%d\n",
					i);
			push_packet(rx_pkts[i], clsd_data + clsd_idx);
		} else if (unlikely(clsd_idx == -1)) {
			LOG_DBG(cmp_info->name, "no destination. "
					"drop packet. i=%d\n", i);
			rte_pktmbuf_free(rx_pkts[i]);
		} else if (unlikely(clsd_idx == -2)) {
			LOG_DBG(cmp_info->name, "as multicast packet. i=%d\n",
					i);
			handle_l2multicast_packet(rx_pkts[i],
					cmp_info, clsd_data);
		}
	}
}

/* change update index at classifier management information */
static inline void
change_classifier_index(struct management_info *mng_info, int id)
{
	if (unlikely(mng_info->ref_index ==
			mng_info->upd_index)) {
		/* Change reference index of port ability. */
		spp_port_ability_change_index(PORT_ABILITY_CHG_INDEX_REF,
									0, 0);

		/* Transmit all packets for switching the using data. */
		transmit_all_packet(mng_info->cmp_infos +
				mng_info->ref_index);

		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
				"Core[%u] Change update index.\n", id);
		mng_info->ref_index =
				(mng_info->upd_index + 1) %
				NUM_CLASSIFIER_MAC_INFO;
	}
}

/* classifier(mac address) initialize globals. */
int
spp_classifier_mac_init(void)
{
	memset(g_mng_infos, 0, sizeof(g_mng_infos));

	return 0;
}

/* initialize classifier information. */
void
init_classifier_info(int component_id)
{
	struct management_info *mng_info = NULL;

	mng_info = g_mng_infos + component_id;
	uninit_classifier(mng_info);
}

/* classifier(mac address) update component info. */
int
spp_classifier_mac_update(struct spp_component_info *component_info)
{
	int ret = SPP_RET_NG;
	int id = component_info->component_id;
	struct management_info *mng_info = g_mng_infos + id;
	struct component_info *cmp_info = NULL;

	RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
			"Component[%u] Start update component.\n", id);

	cmp_info = mng_info->cmp_infos + mng_info->upd_index;

	/* initialize update side classifier information */
	ret = init_component_info(cmp_info, component_info);
	if (unlikely(ret != SPP_RET_OK)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
				"Cannot update classifier mac. ret=%d\n", ret);
		return ret;
	}
	memcpy(cmp_info->name, component_info->name, SPP_NAME_STR_LEN);

	/* change index of reference side */
	mng_info->upd_index = mng_info->ref_index;
	mng_info->is_used = 1;

	/* wait until no longer access the new update side */
	while (likely(mng_info->ref_index ==
			mng_info->upd_index))
		rte_delay_us_block(CHANGE_UPDATE_INDEX_WAIT_INTERVAL);

	/* uninitialize old */
	uninit_component_info(mng_info->cmp_infos + mng_info->upd_index);

	RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
			"Component[%u] Complete update component.\n", id);

	return SPP_RET_OK;
}

/* classifier(mac address) thread function. */
int
spp_classifier_mac_do(int id)
{
	int i;
	int n_rx;
	struct management_info *mng_info = g_mng_infos + id;
	struct component_info *cmp_info = NULL;
	struct rte_mbuf *rx_pkts[MAX_PKT_BURST];

	struct classified_data *clsd_data_rx = NULL;
	struct classified_data *clsd_data_tx = NULL;

	uint64_t cur_tsc, prev_tsc = 0;
	const uint64_t drain_tsc = (rte_get_tsc_hz() + US_PER_S - 1) /
			US_PER_S * DRAIN_TX_PACKET_INTERVAL;

	/* change index of update classifier management information */
	change_classifier_index(mng_info, id);

	cmp_info = mng_info->cmp_infos + mng_info->ref_index;
	clsd_data_rx = &cmp_info->classified_data_rx;
	clsd_data_tx = cmp_info->classified_data_tx;

	/**
	 * decide classifier information of the current cycle If at least,
	 * one rx port, one tx port and one classifier_table exist, then start
	 * classifying. If not, stop classifying.
	 */
	if (!(clsd_data_rx->iface_type != UNDEF &&
			cmp_info->n_classified_data_tx >= 1 &&
				cmp_info->mac_addr_entry == 1))
		return SPP_RET_OK;

	/* drain tx packets, if buffer is not filled for interval */
	cur_tsc = rte_rdtsc();
	if (unlikely(cur_tsc - prev_tsc > drain_tsc)) {
		for (i = 0; i < cmp_info->n_classified_data_tx; i++) {
			if (likely(clsd_data_tx[i].num_pkt == 0))
				continue;

			RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
					"transmit packets (drain). index=%d, "
					"num_pkt=%hu, interval=%lu\n",
					i, clsd_data_tx[i].num_pkt,
					cur_tsc - prev_tsc);
				transmit_packet(&clsd_data_tx[i]);
		}
		prev_tsc = cur_tsc;
	}

	if (clsd_data_rx->iface_type == UNDEF)
		return SPP_RET_OK;

	/* retrieve packets */
	n_rx = spp_eth_rx_burst(clsd_data_rx->port, 0, rx_pkts, MAX_PKT_BURST);
	if (unlikely(n_rx == 0))
		return SPP_RET_OK;

	/* classify and interval that transmit burst packet */
	classify_packet(rx_pkts, n_rx, cmp_info, clsd_data_tx);

	return SPP_RET_OK;
}

/* classifier iterate component information */
int
spp_classifier_get_component_status(
		unsigned int lcore_id, int id,
		struct spp_iterate_core_params *params)
{
	int ret = SPP_RET_NG;
	int i, num_tx, num_rx = 0;
	struct management_info *mng_info;
	struct component_info *cmp_info;
	struct classified_data *clsd_data;
	struct spp_port_index rx_ports[RTE_MAX_ETHPORTS];
	struct spp_port_index tx_ports[RTE_MAX_ETHPORTS];

	mng_info = g_mng_infos + id;
	if (!is_used_mng_info(mng_info)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
				"Component[%d] Not used. "
				"(status)(core = %d, type = %d)\n",
				id, lcore_id, SPP_COMPONENT_CLASSIFIER_MAC);
		return SPP_RET_NG;
	}

	cmp_info = mng_info->cmp_infos + mng_info->ref_index;
	clsd_data = cmp_info->classified_data_tx;

	memset(rx_ports, 0x00, sizeof(rx_ports));
	if (cmp_info->classified_data_rx.iface_type != UNDEF) {
		num_rx = 1;
		rx_ports[0].iface_type = cmp_info->
				classified_data_rx.iface_type;
		rx_ports[0].iface_no   = cmp_info->
				classified_data_rx.iface_no_global;
	}

	memset(tx_ports, 0x00, sizeof(tx_ports));
	num_tx = cmp_info->n_classified_data_tx;
	for (i = 0; i < num_tx; i++) {
		tx_ports[i].iface_type = clsd_data[i].iface_type;
		tx_ports[i].iface_no   = clsd_data[i].iface_no_global;
	}

	/* Set the information with the function specified by the command. */
	ret = (*params->element_proc)(
		params, lcore_id,
		cmp_info->name, SPP_TYPE_CLASSIFIER_MAC_STR,
		num_rx, rx_ports, num_tx, tx_ports);
	if (unlikely(ret != SPP_RET_OK))
		return SPP_RET_NG;

	return SPP_RET_OK;
}

static void
mac_classification_iterate_table(
		struct spp_iterate_classifier_table_params *params,
		uint16_t vid,
		struct mac_classification *mac_cls,
		__rte_unused struct component_info *cmp_info,
		struct classified_data *clsd_data)
{
	int ret;
	const void *key;
	void *data;
	uint32_t next;
	struct spp_port_index port;
	char mac_addr_str[ETHER_ADDR_STR_BUF_SZ];
	enum spp_classifier_type type;

	type = SPP_CLASSIFIER_TYPE_VLAN;
	if (unlikely(vid == VLAN_UNTAGGED_VID))
		type = SPP_CLASSIFIER_TYPE_MAC;

	if (mac_cls->default_classified >= 0) {
		port.iface_type = (clsd_data +
				mac_cls->default_classified)->iface_type;
		port.iface_no   = (clsd_data +
				mac_cls->default_classified)->iface_no_global;

		LOG_ENT((long)mac_cls->default_classified,
				vid,
				SPP_DEFAULT_CLASSIFIED_SPEC_STR,
				cmp_info, clsd_data);

		(*params->element_proc)(
				params,
				type,
				vid,
				SPP_DEFAULT_CLASSIFIED_SPEC_STR,
				&port);
	}

	next = 0;
	while (1) {
		ret = rte_hash_iterate(mac_cls->classification_tab,
				&key, &data, &next);

		if (unlikely(ret < 0))
			break;

		ether_format_addr(mac_addr_str, sizeof(mac_addr_str),
				(const struct ether_addr *)key);

		port.iface_type = (clsd_data + (long)data)->iface_type;
		port.iface_no   = (clsd_data + (long)data)->iface_no_global;

		LOG_ENT((long)data, vid, mac_addr_str, cmp_info, clsd_data);

		(*params->element_proc)(
				params,
				type,
				vid,
				mac_addr_str,
				&port);
	}
}

/* classifier(mac address) iterate classifier table. */
int
spp_classifier_mac_iterate_table(
		struct spp_iterate_classifier_table_params *params)
{
	int i, n;
	struct management_info *mng_info;
	struct component_info *cmp_info;
	struct classified_data *clsd_data;

	for (i = 0; i < RTE_MAX_LCORE; i++) {
		mng_info = g_mng_infos + i;
		if (!is_used_mng_info(mng_info))
			continue;

		cmp_info = mng_info->cmp_infos + mng_info->ref_index;
		clsd_data = cmp_info->classified_data_tx;

		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
			"Core[%u] Start iterate classifier table.\n", i);

		for (n = 0; n < SPP_NUM_VLAN_VID; ++n) {
			if (cmp_info->mac_classifications[n] == NULL)
				continue;

			mac_classification_iterate_table(
					params,
					(uint16_t)n,
					cmp_info->mac_classifications[n],
					cmp_info,
					clsd_data);
		}
	}

	return SPP_RET_OK;
}
